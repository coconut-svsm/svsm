// SPDX-License-Identifier: MIT OR Apache-2.0
//
// Copyright (c) Microsoft Corporation
//
// Author: Jon Lange (jlange@microsoft.com)

use super::GuestExitMessage;
use crate::cpu::percpu::this_cpu;
use crate::cpu::{flush_tlb_global_sync, IrqGuard};
use crate::sev::ghcb::switch_to_vmpl;
use crate::sev::vmsa::VMSAControl;
use crate::types::GUEST_VMPL;

pub fn enter_guest() -> GuestExitMessage {
    let cpu = this_cpu();

    // If no VMSA or CAA are configured, then the guest cannot be entered.
    if cpu.update_guest_mappings().is_err() {
        return GuestExitMessage::NoMappings;
    }

    // No interrupts may be processed once guest APIC state is updated, since
    // handling an interrupt may modify the guest APIC state calculations,
    // which could cause state corruption.  If interrupts are disabled, then
    // any additional guest APIC updates generated by the host will block the
    // VMPL transition and permit reevaluation of guest APIC state.
    let guard = IrqGuard::new();

    // Update APIC interrupt emulation state if required.
    let mut vmsa_ref = cpu.guest_vmsa_ref();
    let caa_addr = vmsa_ref.caa_addr();
    let vmsa = vmsa_ref.vmsa();
    cpu.update_apic_emulation(vmsa, caa_addr);

    // Make VMSA runnable again by setting EFER.SVME.
    vmsa.enable();

    // The VMSA reference must not be held when the guest is running.
    drop(vmsa_ref);

    flush_tlb_global_sync();

    switch_to_vmpl(GUEST_VMPL as u32);

    // Interrupts can safely be reenabled once the guest has returned to the
    // SVSM.
    drop(guard);

    // If no mapping exists, then indicate to the caller that the guest exited
    // with no valid mappings.
    if cpu.update_guest_mappings().is_err() {
        return GuestExitMessage::NoMappings;
    }

    // Obtain a reference to the VMSA just long enough to extract the request
    // parameters.
    let (protocol, request) = {
        let mut vmsa_ref = cpu.guest_vmsa_ref();
        let vmsa = vmsa_ref.vmsa();

        // Clear EFER.SVME in guest VMSA.
        vmsa.disable();

        let rax = vmsa.rax;

        ((rax >> 32) as u32, (rax & 0xffff_ffff) as u32)
    };

    // Return all SVSM protocol requests to the caller.
    GuestExitMessage::Svsm((protocol, request))
}
