// SPDX-License-Identifier: MIT OR Apache-2.0
//
// Copyright (c) Microsoft Corporation
//
// Author: Jon Lange (jlange@microsoft.com)

use super::{set_guest_register, GuestExitMessage, GuestRegister};
use crate::cpu::percpu::{this_cpu, GuestVmsaRef};
use crate::cpu::{flush_tlb_global_sync, IrqGuard};
use crate::mm::access::{ReadableMapping, WriteableMapping};
use crate::protocols::errors::SvsmReqError;
use crate::protocols::RequestParams;
use crate::sev::ghcb::switch_to_vmpl;
use crate::sev::vmsa::VMSAControl;
use crate::types::GUEST_VMPL;

use core::ops::DerefMut;
use cpuarch::vmsa::GuestVMExit;

fn get_and_clear_caa_request_flag(vmsa_ref: &GuestVmsaRef) -> Result<bool, SvsmReqError> {
    if let Some(mut calling_area) = vmsa_ref.caa_addr() {
        let caa = calling_area.read()?;

        let caa_serviced = caa.serviced();

        calling_area.write(caa_serviced)?;

        Ok(caa.call_pending())
    } else {
        Ok(false)
    }
}

fn get_svsm_request_message(vmsa_ref: &mut GuestVmsaRef) -> Option<GuestExitMessage> {
    let vmsa = vmsa_ref.vmsa();

    // Ignore guest exits that were not initiated by VMFEXIT.
    if !matches!(vmsa.guest_exit_code, GuestVMExit::VMGEXIT) {
        return None;
    }
    let rax = vmsa.rax;
    let protocol = (rax >> 32) as u32;
    let request = (rax & 0xffff_ffff) as u32;
    let params = RequestParams::from_vmsa(vmsa);

    match get_and_clear_caa_request_flag(vmsa_ref) {
        Ok(pending) => {
            if pending {
                return Some(GuestExitMessage::Svsm((protocol, request, params)));
            }
        }
        Err(SvsmReqError::RequestError(code)) => {
            log::debug!(
                "Soft error handling protocol {} request {}: {:?}",
                protocol,
                request,
                code
            );
        }
        Err(SvsmReqError::FatalError(err)) => {
            panic!(
                "Fatal error handling core protocol request {}: {:?}",
                request, err
            );
        }
    }

    None
}

pub fn enter_guest(mut regs: &[GuestRegister]) -> GuestExitMessage {
    let cpu = this_cpu();

    // If no VMSA or CAA are configured, then the guest cannot be entered.
    if cpu.update_guest_mappings().is_err() {
        return GuestExitMessage::NoMappings;
    }

    loop {
        // Modify guest registers before disabling interrupts.
        let mut vmsa_ref = cpu.guest_vmsa_ref();
        let caa = vmsa_ref.caa_addr();
        let vmsa = vmsa_ref.vmsa();

        for reg in regs {
            set_guest_register(vmsa, reg);
        }

        // Ensure that no further register modification occurs if the loop
        // restarts.
        regs = &[];

        // No interrupts may be processed once guest APIC state is updated,
        // since handling an interrupt may modify the guest APIC state
        // calculations, which could cause state corruption.  If interrupts are
        // disabled, then any additional guest APIC updates generated by the
        // host will block the VMPL transition and permit reevaluation of
        // guest APIC state.
        let guard = IrqGuard::new();

        // Update APIC interrupt emulation state if required.
        cpu.update_apic_emulation(vmsa, caa);

        // Make VMSA runnable again by setting EFER.SVME.
        vmsa.enable();

        // The VMSA reference must not be held when the guest is running.
        drop(vmsa_ref);

        flush_tlb_global_sync();

        switch_to_vmpl(GUEST_VMPL as u32);

        // Interrupts can safely be reenabled once the guest has returned to the
        // SVSM.
        drop(guard);

        // If no mapping exists, then indicate to the caller that the guest
        // exited with no valid mappings.
        if cpu.update_guest_mappings().is_err() {
            return GuestExitMessage::NoMappings;
        }

        // Obtain a reference to the VMSA just long enough to extract the
        // request parameters.
        {
            let mut vmsa_ref = cpu.guest_vmsa_ref();
            let vmsa = vmsa_ref.vmsa();

            // Clear EFER.SVME in guest VMSA.
            vmsa.disable();

            if let Some(msg) = get_svsm_request_message(vmsa_ref.deref_mut()) {
                return msg;
            }
        }
    }
}
