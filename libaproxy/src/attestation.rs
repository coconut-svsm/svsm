// SPDX-License-Identifier: MIT OR Apache-2.0
//
// Copyright (c) 2024 Red Hat, Inc
//
// Author: Stefano Garzarella <sgarzare@redhat.com>
// Author: Tyler Fanelli <tfanelli@redhat.com>

extern crate alloc;
use super::Error;
use alloc::{
    string::{String, ToString},
    vec::Vec,
};
use base64::{prelude::BASE64_URL_SAFE_NO_PAD, Engine};
use cocoon_tpm_tpm2_interface::{Tpm2bEccParameter, TpmBuffer, TpmEccCurve, TpmsEccPoint};
use core::convert::TryFrom;
use kbs_types::{Tee, TeePubKey};
use serde::{Deserialize, Serialize};

type Result<T> = core::result::Result<T, Error>;

/// The format of the public key that is used to encrypt secrets sent to SVSM upon successful
/// attestation.
///
/// Based on JSON Web Key
/// See for examples: <https://www.rfc-editor.org/rfc/rfc7517#appendix-A.1>
#[derive(Serialize, Deserialize, Debug)]
pub struct EcP256PublicKey {
    pub x: Vec<u8>,
    pub y: Vec<u8>,
}

impl From<(TpmEccCurve, &TpmsEccPoint<'static>)> for EcP256PublicKey {
    fn from(args: (TpmEccCurve, &TpmsEccPoint<'static>)) -> Self {
        Self {
            x: args.1.x.buffer.to_vec(),
            y: args.1.y.buffer.to_vec(),
        }
    }
}

impl From<EcP256PublicKey> for TpmsEccPoint<'static> {
    fn from(arg: EcP256PublicKey) -> Self {
        TpmsEccPoint {
            x: Tpm2bEccParameter {
                buffer: TpmBuffer::Owned(arg.x),
            },
            y: Tpm2bEccParameter {
                buffer: TpmBuffer::Owned(arg.y),
            },
        }
    }
}

impl From<EcP256PublicKey> for TeePubKey {
    fn from(arg: EcP256PublicKey) -> Self {
        Self::EC {
            alg: "ECDH-ES+A256KW".to_string(),
            crv: "P-521".to_string(),
            x: BASE64_URL_SAFE_NO_PAD.encode(arg.x),
            y: BASE64_URL_SAFE_NO_PAD.encode(arg.y),
        }
    }
}

impl TryFrom<TeePubKey> for EcP256PublicKey {
    type Error = super::Error;

    fn try_from(arg: TeePubKey) -> Result<Self> {
        let TeePubKey::EC { crv, alg, x, y } = arg else {
            return Err(Error::InvalidKeyType);
        };

        if crv != "P-521" || alg != "ECDH-ES+A256KW" {
            return Err(Error::InvalidKeyType);
        };

        let key = Self {
            x: BASE64_URL_SAFE_NO_PAD
                .decode(&x)
                .map_err(Error::KeyParamDecode)?,
            y: BASE64_URL_SAFE_NO_PAD
                .decode(&y)
                .map_err(Error::KeyParamDecode)?,
        };

        Ok(key)
    }
}

/// The attestation request payload sent to the proxy from SVSM.
#[derive(Serialize, Deserialize, Debug)]
pub struct AttestationRequest {
    /// TEE architecture.
    pub tee: Tee,
    /// Attestation evidence generated by SVSM
    pub evidence: AttestationEvidence,
    /// Challenge returned in negotiation response.
    pub challenge: Vec<u8>,
    /// Public key generated by SVSM to receive the secret
    pub key: EcP256PublicKey,
}

/// The attestation evidence based on the underlying TEE architecture.
#[derive(Serialize, Deserialize, Debug)]
pub enum AttestationEvidence {
    /// SEV-SNP evidence.
    Snp {
        /// SEV-SNP attestation report.
        report: Vec<u8>,
        /// Certificates that may be available from the host hypervisor.
        certs_buf: Option<Vec<u8>>,
    },
}

/// Token typically returned in successful attestations.
#[derive(Serialize, Deserialize, Debug)]
pub enum AttestationToken {
    /// Token serialized to JSON (JWT).
    Jwt(String),
    /// Token serialized to CBOR (CWT).
    Cwt(String),
}

/// Response from proxy to SVSM indicating the status of attestation as well as an optional secret
/// if successful.
#[derive(Serialize, Deserialize, Debug)]
pub struct AttestationResponse {
    /// Remote attestation result
    pub success: bool,
    /// Secret encrypted with the key generated by SVSM
    pub secret: Option<Vec<u8>>,
    /// Server's public key used for symmetric encryption/decryption.
    pub decryption: Option<AesGcmData>,
    /// EAR or other token received from successful attestation.
    pub token: Option<AttestationToken>,
}

/// Data required for decryption with ECDH-ES+A256KW encryption. Described in RFC 7518,
/// section 4.6.2.
#[derive(Serialize, Deserialize, Debug)]
pub struct AesGcmData {
    // Ephemeral public key. Required for ECDH handshake unwrapping the Content Encryption Key
    // (CEK).
    pub epk: EcP256PublicKey,
    // Encrypted Content Encryption Key (CEK).
    pub wrapped_cek: Vec<u8>,
    // Additional Authenticated Data (AAD). Used to authenticate the message, ensuring that it has
    // not been tampered with.
    pub aad: Vec<u8>,
    // Initialization vector.
    pub iv: Vec<u8>,
    // Authentication tag.
    pub tag: Vec<u8>,
}
