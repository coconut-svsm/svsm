// SPDX-License-Identifier: MIT OR Apache-2.0
//
// Copyright (c) 2024 Red Hat, Inc
//
// Author: Stefano Garzarella <sgarzare@redhat.com>
// Author: Tyler Fanelli <tfanelli@redhat.com>

extern crate alloc;
use alloc::{
    string::{String, ToString},
    vec::Vec,
};
use base64::prelude::*;
use cocoon_tpm_crypto::CryptoError;
use cocoon_tpm_tpm2_interface::{Tpm2bEccParameter, TpmBuffer, TpmEccCurve, TpmsEccPoint};
use core::convert::TryFrom;
use serde::{Deserialize, Serialize};

/// The format of the public key that is used to encrypt secrets sent to SVSM upon successful
/// attestation.
///
/// Based on JSON Web Key
/// See for examples: <https://www.rfc-editor.org/rfc/rfc7517#appendix-A.1>
#[derive(Serialize, Deserialize, Debug)]
pub enum AttestationKey {
    EC {
        crv: String,
        x_b64url: String,
        y_b64url: String,
    },
}

impl TryFrom<(TpmEccCurve, &TpmsEccPoint<'static>)> for AttestationKey {
    type Error = CryptoError;

    fn try_from(args: (TpmEccCurve, &TpmsEccPoint<'static>)) -> Result<Self, Self::Error> {
        let x_b64url = BASE64_URL_SAFE.encode(&*args.1.x.buffer);
        let y_b64url = BASE64_URL_SAFE.encode(&*args.1.y.buffer);

        let crv = match args.0 {
            TpmEccCurve::NistP224 => "EC224",
            TpmEccCurve::NistP256 => "EC256",
            TpmEccCurve::NistP384 => "EC384",
            TpmEccCurve::NistP521 => "EC521",
            _ => return Err(CryptoError::InvalidParams),
        }
        .to_string();

        Ok(AttestationKey::EC {
            crv,
            x_b64url,
            y_b64url,
        })
    }
}

impl TryFrom<AttestationKey> for TpmsEccPoint<'static> {
    type Error = CryptoError;

    fn try_from(arg: AttestationKey) -> Result<Self, CryptoError> {
        match arg {
            AttestationKey::EC {
                crv: _,
                x_b64url,
                y_b64url,
            } => {
                let x_buf = BASE64_URL_SAFE
                    .decode(&x_b64url)
                    .map_err(|_| CryptoError::InvalidParams)?;
                let y_buf = BASE64_URL_SAFE
                    .decode(&y_b64url)
                    .map_err(|_| CryptoError::InvalidParams)?;

                let point = TpmsEccPoint {
                    x: Tpm2bEccParameter {
                        buffer: TpmBuffer::Owned(x_buf),
                    },
                    y: Tpm2bEccParameter {
                        buffer: TpmBuffer::Owned(y_buf),
                    },
                };

                Ok(point)
            }
        }
    }
}

/// The attestation request payload sent to the proxy from SVSM.
#[derive(Serialize, Deserialize, Debug)]
pub struct AttestationRequest {
    /// Attestation evidence generated by SVSM
    pub evidence: String,
    /// Challenge returned in negotiation response.
    pub challenge: Vec<u8>,
    /// Public key generated by SVSM to receive the secret
    pub key: AttestationKey,
}

/// Response from proxy to SVSM indicating the status of attestation as well as an optional secret
/// if successful.
#[derive(Serialize, Deserialize, Debug)]
pub struct AttestationResponse {
    /// Remote attestation result
    pub success: bool,
    /// Secret encrypted with the key generated by SVSM
    pub secret: Option<Vec<u8>>,
    /// Server's public key used for symmetric encryption/decryption.
    pub pub_key: Option<AttestationKey>,
}
